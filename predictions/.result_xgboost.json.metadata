{"timestamp": 1687183571.141881, "stored_source_code": "upstream = None\nproduct = None\nimport json\nimport pickle\nimport warnings\nfrom pathlib import Path\n\nimport numpy as np\nimport pandas as pd\nimport xgboost as xgb\n\nwarnings.filterwarnings('ignore')\ncols = ['is_beverage', 'non_recyclable_and_non_biodegradable_materials_count', \n        'est_co2_agriculture', 'est_co2_consumption', \n        'est_co2_distribution', 'est_co2_packaging', 'est_co2_processing', \n        'est_co2_transportation'] \ntarget_col = 'ecoscore_grade'\ntrain = pd.read_csv(upstream['Preprocess features']['train_csv'], usecols=cols + [target_col])\ntest = pd.read_csv(upstream['Preprocess features']['test_csv'], usecols=cols)\nX_train, y_train = train[cols], train[target_col]\nX_test = test[cols]\nfor i in cols:\n    X_train[i] = X_train[i].astype(float)\n    X_test[i] = X_test[i].astype(float)\nprint(X_train.shape, y_train.shape)\nprint(X_test.shape)\ndtrain = xgb.DMatrix(X_train, label=y_train.values)\ndvalid = xgb.DMatrix(X_test)\nevals_result = {}\nwatchlist = [(dtrain, \"train\")]\nparams = {\n    \"seed\": 0,\n    \"eta\": 0.1,\n    \"alpha\": 15,\n    # \"gamma\": 25,\n    # \"lambda\": 15,\n    \"max_depth\": 15,\n    \"refresh_leaf\": 1,\n    \"booster\": \"gbtree\",\n    \"max_delta_step\": 1,\n    \"n_estimators\": 1000,\n    # \"colsample_bytree\": 0.1,\n    # \"colsample_bylevel\": 0.8,\n    # \"min_child_weight\": 11.0,\n    # \"seed_per_iteration\": True,\n    'subsample': .1,\n    \"objective\": \"multi:softprob\",\n    'num_class': len(y_train.unique()),\n    \"eval_metric\": [\"auc\", \"mlogloss\"],\n}\neta_decay = np.linspace(params['eta'], 0.01, 2000).tolist()\nmodel = xgb.train(\n    params,\n    dtrain,\n    params.pop(\"n_estimators\"),\n    evals=watchlist,\n    verbose_eval=True,\n    evals_result=evals_result,\n    callbacks=[xgb.callback.LearningRateScheduler(eta_decay)],\n)\nPath(product['result'])\\\n    .write_text(json.dumps(\n        {'target': {index: int(i) \n                    for index, i in enumerate(np.argmax(model.predict(dvalid), axis=1))}\n         }))", "params": {}}